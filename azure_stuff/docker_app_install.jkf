// pull docker images and install using docker-compose
// target IPv4 address and port to expose are input parameters

def myCheckout(myGitUrl, myBranch, myLocalDir) {
    checkout changelog: false, poll: false, scm: [$class: 'GitSCM',
    branches: [[name: myBranch]],
    doGenerateSubmoduleConfigurations: false,
    extensions: [[$class: 'RelativeTargetDirectory',
    relativeTargetDir: myLocalDir]],
    submoduleCfg: [],
    userRemoteConfigs: [[credentialsId: 'GithubSSH',
    url: myGitUrl]]
    ]

def validateIP4(vm_ip4) {
    println "check valid ip-address is given: "
    def ip = vm_ip4
    def octets = (vm_ip4).tokenize( '.' )
    println "Octet1: " + octets[0] + " :: Octet2: " + octets[1] + " :: Octet3: " + octets[2] + " :: Octet4: " + octets[3]

    if ( octets.size() != 4) { println "No. of octets is not 4" }
    def valid = true
    for (i = 0; i < octets.size(); i++) {     
        if ( (! octets[i].isNumber()) || (octets[i].toInteger() < 0) )
            { println "IP " + ip + " :: " + octets[i] + " is not valid"; valid = false ; break }
        if ( ( i == 0 ) && ( octets[i].toInteger() == 0 ) ) { println "first octet of IP cannot be zero"; valid = false; break }
        if ( octets[i].toInteger() > 254 ) { println "IP " + ip + " :: " + octets[i] + " is not valid"; valid = false ; break  }
    }
    println "Is ip valid? " + valid 
    env.IP_IS_VALID = valid        
}

// Inputs: env.VM_IPV4  env.APP_ACCESS_PORT

//node('JENKINS_SLAVE_3') {
node() {
    stage('Validate IP4'){
        if(env.VM_IP4) {
            validateIP4(env.VM_IP4)
        } else {
            println ("IP Address is Null, failing the build")
            currentBuild.result = 'FAILED'
            return
        }
        if ( env.IP_IS_VALID == "false" ) {
            println "Given IP Adress " + env.VM_IP4 + " for targeted host is invalid. "
            error('Failing the build.')
            currentBuild.result = 'FAILED'
            return
        } 
    }

    stage('store private key') {
        withCredentials([sshUserPrivateKey(credentialsId: 'AzurePEMKey', 
        keyFileVariable: 'myPEMFile', 
        passphraseVariable: '', 
        usernameVariable: 'AzureUser')]) {
        writeFile file: 'azure/azure_user', text: AzureUser
        writeFile file: 'azure/azure_pem', text: myPEMFile
        sh '''#!/bin/bash -l
                cat $myPEMFile > ~/.ssh/thisHost_rsa
                chmod 600 ~/.ssh/thisHost_rsa
           '''
        }
    }

    stage('retrieve azure user') {
        env.azure_user = readFile(file: 'azure/azure_user')
        println(azure_user)
    }

    stage('clone the git') {
        echo "Cloning git"
        def parthak8_url = "git@github.com:ParthaK8/codesamples"
        def parthak8_branch = "*/testoper-testing"
        def local_dir = "parthak8"
        myCheckout(parthak8_url, parthak8_branch, local_dir)

        // set an environment variable, value of local_dir
        env.LOCAL_DIR = local_dir
        
        // Verify
        sh "ls -la"
        sh "ls -la ${LOCAL_DIR}"
        def CWDABSPATH
        CWDABSPATH = sh (
        script: "echo `pwd`",
                returnStdout: true
        ).trim()
        println "Current Working Directory: " + CWDABSPATH
        env.BASEPATH = CWDABSPATH  // set env var for BASEPATH
    }

    stage('install nextcloud') {
        sh '''#!/bin/bash -l   
                ssh-keygen -R ${VM_IP4}
                ssh-keyscan ${VM_IP4}  >> ~/.ssh/known_hosts  
                ls -la $HOME/.ssh
                scp -i $HOME/.ssh/thisHost_rsa parthak8/azure_stuff/nextcloud_install.sh /tmp
                ssh -i $HOME/.ssh/thisHost_rsa ${azure_user}@${VM_IP4} /tmp/nextcloud_install.sh
            '''
    }
}
